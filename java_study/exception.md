# チェック例外、実行時例外、エラー

Javaの例外まわりは以下のようなクラス構造になっている。

```
java.lang.Throwable
  ├─　java.lang.Error
  |　   └─　java.lang.AssertionError
  └─ java.lang.Exception
　      └─ java.lang.RuntimeException
```

以下のように分類される。

- チェック例外
  - ```java.lang.Exception``` を継承した例外
  - ```try-catch``` 、 ```throws``` が **必要**
  - **呼び出し側** 、 **呼び出される側** 以外の処理でバグが発生したことを知らせるもの
- 実行時例外 （非チェック例外）
  - ```java.lang.RuntimeException``` を継承した例外
  - ```try-catch``` 、 ```throws``` が **不要** （やってもいい）
  - **呼び出し側** の処理でバグが発生したことを知らせるもの
- エラー
  - ```java.lang.Error``` を継承したクラス、例外ではない
  - ```try-catch``` 、 ```throws``` が **不要** （やるべきではない）
  - **呼び出される側** の処理でバグが発生したことを知らせるもの

**呼び出し側** 、 **呼び出される側** の意味は以下の通り。

- **呼び出し側**
  - 例外が発生する可能性のあるクラスやメソッドを使用・呼び出す側の処理
  - アプリケーションに何らかの操作を行う人・外部システム
- **呼び出される側**
  - 例外を発生させる可能性のあるクラスやメソッド自身

Java標準（ ```java.lang``` パッケージ）から例を挙げると以下のようなものがある。

- チェック例外
  - ClassNotFoundException - クラスが見つからなかった。
  - IllegalAccessException:クラスに不正にアクセスしようとした。
  - InstantiationException:インターフェースまたは抽象クラスをインスタンス化しようとした。
  - InterruptedException - スレッドに割り込みが入った。
- 実行時例外 （非チェック例外）
  - ArithmeticException - 算術例外が発生した（整数を0で除算したなど）。
  - ArrayIndexOutOfBoundsException - 配列のindex が実在しない要素を指していた。
  - ArrayStoreException - 不正な型のオブジェクトをオブジェクトの配列に格納しようとした。
  - ClassCastException - 不正な型変換（キャスト）を試みた。
  - IllegalArgumentException - 不正な引数をメソッドに渡した。
  - NullPointerException - 空のオブジェクトのフィールドまたはメソッドにアクセスしようとした。
  - SecurityException:セキュリティ違反のため操作が拒否された。
- エラー
  - ClassFormatError - 形式エラー。
  - StackOverflowError - スタックのオーバーフロー。
  - InternalError - 内部エラー。
  - OutOfMemoryError - メモリ不足。
  - UnknownError - 未知のエラー。

上記以外の例で感覚を掴むとすると、例えば、入力チェックエラーで発生する例外（ ```javax.validation.ValidationException``` ）は **実行時例外** となる。これは、値を入力している **呼び出し側** が不正な入力をしているため。  
また、 ```java.io.IOException``` は **チェック例外** となる。これは、 **呼び出し側にも呼び出され側にも関係ない** ところで入出力処理の失敗が発生しているため。

# 例外の使い方

## 例外を乱用しない

例外処理は遅い。  
通常の処理フローでは例外ハンドリングは利用せず、 **本当に例外的な場合のみ** で使用する。  
また、例外を使用する場合、チェック例外を乱用するのではなく、実行時例外の使用を検討する。

## 例外ハンドリングで処理継続可能な場合は **チェック例外** 、 不可能な場合は **実行時例外**

呼び出し側が適切に例外ハンドリングすることで処理を回復できる場合は **チェック例外** を使用する。  
プログラミングのエラーは **実行時例外** を使用する。メソッド呼び出しの **事前条件違反** なので。  
エラー（ ```Error``` を継承したクラス）は作成すべきでない。

## ```java.lang``` などJava標準提供の例外を使用する

先に紹介したようにJava標準で様々な例外が提供されている。  
例外は乱作成せず、意味が合致するものはJava標準の例外を使用する。

## 例外の抽象レベルをコントロールする

例えば、以下の例外クラスの継承関係がある。

```
javax.validation.ValidationException
  └─ javax.validation.ConstraintDeclarationException
       └─ javax.validation.UnexpectedTypeException
```

ある処理で ```UnexpectedTypeException``` をcatchしたとする。  
これを上位の処理へ ```throw``` する場合、上位の処理にとって入力チェックエラーの細かな内容を伝える必要が無い場合は単に入力チェックエラーが発生したことを伝えればよい。  
具体的には下記のようになる。

```java
try {
  // ...
} catch (UnexpectedTypeException e) {
  throw new ValidationException(e);
}
```

上記の例では、例外を **連鎖** させているが、特に不要な場合は引数に渡す必要もない。

## 例外の発生原因をメッセージに入れる

例外を ```throw``` する際、引数にメッセージを付与することができる。  
その際、例外の原因がわかる場合、メッセージにその内容を記載する。パラメータの値が不正である場合は、「その不正な値」と「どうあるべきか」を記載する。

## データをロールバックする

あるメソッドで処理を行なっていたが、例外が発生したとする。  
例外が発生するまでの過程でデータストレージ・オブジェクトなどの値を操作していた場合、例外処理のなかでデータストレージ・オブジェクトを初期の値に戻す。

# 例外の設計

例外を独自実装する場合、以下の例外で整理する（ことが多い）。

- BusinessException
  - 実行時例外
  - ビジネスロジック内で発生させる、ビジネスルール違反を知らせる例外
- SystemException
  - 実行時例外
  - システムの設定不足・誤りを知らせる例外

上記の例外を継承して詳細度を上げた（より具体的な事象にした）例外を作成する。

## BusinessException

```BusinessException``` には以下のような例がある。

- あ

なお、 ```BusinessException``` を ```throw``` させる際は、引数として例外のメッセージに **例外の発生原因** を記載する。

## SystemException

```SystemException``` には以下のような例がある。

- あ

なお、 ```SystemException``` を ```throw``` させる際は、引数として例外のメッセージに **エラーコード** を記載してトレーサビリティを担保できるようにする。

# 例外ハンドリング

例外をハンドリングする（ ```catch``` の中で行う処理）パターンとして以下がある。

- ログを出力する
- メッセージやエラーコードをセットする
- 例外の抽象度をコントロールする
  - ```XxxBusinessException``` を ```BusinessException``` にするなど
- 例外からメッセージやエラーコードを取り出して、Viewへセットする
- 例外を ```throw``` して、上位の処理・フレームワーク・サーブレットコンテナなどに処理をまかせる
